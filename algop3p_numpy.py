# -*- coding: utf-8 -*-
"""algoP3P_numpy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FduYIvG0YMPjAMFsvhXAEbERImXbzgos
"""

# P3P algorithm code in numpy

import numpy as np

def P3P(pt3D,featuresVectors):
  # 3Dpoints : coordinates of the features points = [P1, P2, P3]  (3*3)
  # featuresVectors = [f1, f2, f3]  (3*3)

  # output : matrix of solutions :  [[C1,R1],[C2,R2],[C3,R3],[C4,R4]] (4*3*4)

  # Features Points
  P1 = pt3D[0]
  P2 = pt3D[1]
  P3 = pt3D[2]

  # Features Vectors
  f1 = featuresVectors[0]
  f2 = featuresVectors[1]
  f3 = featuresVectors[2]

  solutions = np.zeros((4,3,4))     #(4*3*4)

  # Test of non-collinearity
  v1 = P2 - P1
  v2 = P3 - P1
  if np.linalg.norm(np.cross(v1,v2))==0 :
    print('Problem: the points must not be collinear')
    return

  # Calculation of vectors of the base τ = (C,tx,ty,tz)
  tx = f1
  tz = np.cross(f1,f2)/np.linalg.norm(np.cross(f1,f2))
  ty = np.cross(tz,tx)

  tx = np.reshape(tx,(1,3))
  ty = np.reshape(ty,(1,3))
  tz = np.reshape(tz,(1,3))

  # Computation of the matrix T and the feature vector f3
  T = np.concatenate((tx,ty,tz),axis = 0)
  print('T',T,"\n")

  f3_taux = np.dot(T,f3)
  print(f3_taux)

  # Calculation of vectors of the base η = (P1,nx,ny,nz)
  nx = (P2 - P1)/np.linalg.norm(P2 - P1)
  nz = np.cross(nx,P1-P3)/np.linalg.norm(np.cross(nx,P1-P3))
  ny = np.cross(nz,nx)

  nx = np.reshape(nx,(1,3))
  ny = np.reshape(ny,(1,3))
  nz = np.reshape(nz,(1,3))

  # Computation of the matrix N and the world point P3
  N = np.concatenate((nx,ny,nz),axis = 0)
  print('N',N,"\n")

  P3_eta = np.dot(N,P3-P1)

  # Computation of phi1 et phi2
  phi1 = f3_taux[0]/f3_taux[2]
  phi2 = f3_taux[1]/f3_taux[2]

  # Extraction of p1 and p2 from P3_eta
  p1 = P3_eta[0]
  p2 = P3_eta[1]

  # Computation of d12
  d12 = np.linalg.norm(P2-P1)

  # Computation of b = cot(beta)
  cosBeta = np.dot(f1,f2)/(np.linalg.norm(f1)*np.linalg.norm(f2))     #division par norme pas utile si vecteur unitaire ?
  b = np.sqrt(1/(1-cosBeta**2))
  if cosBeta < 0 :
    b = -b

  # Computation of the factors
  a4 = - phi2**2 * p2**4 - phi1**2 * p2**4 - p2**4
  a3 = 2 * p2**3 * d12 * b + 2 * phi2**2 * p2**3 * d12 * b - 2 * phi1 * phi2 * p2**3 * d12
  a2 = - phi2**2 * p1**2 * p2**2 - phi2**2 * p2**2 * d12**2 * b**2 - phi2**2 * p2**2 * d12**2 + phi2**2 * p2**4 + phi1**2 * p2 **4 + 2 * p1 * p2**2 * d12 + 2 * phi1 * phi2 * p1 * p2**2 * d12 * b - phi1**2 * p1**2 * p2**2 + 2 * phi2**2 * p1 * p2**2 * d12 - p2**2 * d12**2 * b**2 - 2 * p1**2 * p2**2
  a1 = 2 * p1**2 * p2 * d12 * b + 2 * phi1 * phi2 * p2**3 * d12 - 2 * phi1**2 * p2**3 * d12 * b - 2 * p1 * p2 * d12**2 * b
  a0 = - 2 * phi1 * phi2 * p1 * p2**2 * d12 * b + phi2**2 * p2**2 * d12**2 + 2 * p1**3 * d12 - p1**2 * d12**2 + phi2**2 * p1**2 * p2**2 - p1**4 - 2 * phi2**2 * p1 * p2**2 * d12 + phi1**2 * p1**2 * p2**2 + phi2**2 * p2**2 * d12**2 * b**2

  # Computation of the roots
  roots = roots_ferrari(np.array([a0,a1,a2,a3,a4]))

  # For each solution of the polynomial
  for i in range(4):

    # Computation of trigonometrics forms
    cos_teta = np.real(roots[i])
    sin_teta = np.sqrt(1-cos_teta**2)

    cot_alpha = ((phi1/phi2)*p1 + cos_teta*p2 -d12*b )/ ((phi1/phi2)*cos_teta*p2 - p1 + d12)

    sin_alpha = np.sqrt(1/(cot_alpha**2+1))
    cos_alpha= np.sqrt(1-sin_alpha**2)

    if cot_alpha < 0 :
      cos_alpha = -cos_alpha

    # Computation of the intermediate rotation's matrixs
    C = [d12*cos_alpha*(sin_alpha*b + cos_alpha), d12*sin_alpha*cos_teta*(sin_alpha*b+cos_alpha), d12*sin_alpha*sin_teta*(sin_alpha*b+cos_alpha)]
    Q = [[-cos_alpha, -sin_alpha*cos_teta, -sin_alpha*sin_teta], [sin_alpha, -cos_alpha*cos_teta, cos_alpha*sin_teta], [0, -sin_teta, cos_teta]]

    # Computation of the absolute calera center
    C = P1 + np.transpose(N) @ C
    C = C[:,np.newaxis]
    # Computation of the orientation matrix
    R = np.transpose(N) @ np.transpose(Q) @ T

    # Adding C and R to the solutions
    solutions[i,:,:1]= C
    solutions[i,:,1:] = R


  return solutions

Pt3D = np.array([[0, 0, 1], [1, 7, 6], [3, 65, 6]])
fet = np.array([[0, 0, 1], [1, 3, 4], [3, 5, 6]])

sol = P3P(Pt3D,fet)
print(sol)

def roots_ferrari(a):
    # input : array 5*1
    # output : roots of the polynomial a[4]*x^4 + a[3]*x^3 + a[2]*x^2 + a[1]*x + a[0]     array 4*1
    print(np.shape(a))
    if np.shape(a)[0] != 5 :
      print("Expeted 5 coefficiants for a 4th order polynomial")
      return

    a0 = a[0]
    a1 = a[1]
    a2 = a[2]
    a3 = a[3]
    a4 = a[4]

    # Reduce the quartic equation to to form : x^4 + a*x^3 + b*x^2 + c*x + d = 0
    a = a3/a4
    b = a2/a4
    c = a1/a4
    d = a0/a4

    # Computation of the coefficients of the Ferrari's Method
    S = a/4
    b0 = d - c*S + b* S**2 - 3* S**4
    b1 = c - 2*b*S + 8*S**3
    b2 = b - 6 * S**2


    # Solve the cubic equation m^3 + b2*m^2 + (b2^2/4  - b0)*m - b1^2/8 = 0
    x_cube = roots_cubic(1,b2,(b2**2)/4-b0,(-b1**2)/8)
    # Find a real and positive solution
    print(x_cube)
    alpha_0 = 0
    for r in x_cube :
      if np.isclose(np.imag(r),0) and np.real(r) > 0 :
        alpha_0 = r
    print('alpha_0 : ', alpha_0)

    if alpha_0 !=0 :
      x1 = np.sqrt(alpha_0/2) - S  + np.sqrt( -alpha_0/2 - b2/2 - b1/(2*np.sqrt(2*alpha_0)),dtype = complex)
      x2 = np.sqrt(alpha_0/2) - S - np.sqrt( -alpha_0/2 - b2/2 - b1/(2*np.sqrt(2*alpha_0,)),dtype = complex)
      x3 = - np.sqrt(alpha_0/2) - S + np.sqrt( -alpha_0/2 - b2/2 + b1/(2*np.sqrt(2*alpha_0)),dtype = complex)
      x4 = - np.sqrt(alpha_0/2) - S - np.sqrt( -alpha_0/2 - b2/2 + b1/(2*np.sqrt(2*alpha_0)),dtype = complex)

    else :
      print("racine",b2**2/4 - b0)
      x1 = - S + np.sqrt(-b2/2 + np.sqrt((b2**2)/4 - b0),dtype = complex)
      x2 = - S - np.sqrt(-b2/2 + np.sqrt((b2**2)/4 - b0),dtype = complex)
      x3 = - S + np.sqrt(-b2/2 - np.sqrt((b2**2)/4 - b0),dtype = complex)
      x4 = - S - np.sqrt(-b2/2 - np.sqrt((b2**2)/4 - b0),dtype = complex)
    return np.array([x1,x2,x3,x4])

def sqrt_3(x) :
  if np.real(x) >= 0 :
    return x**(1/3)
  else :
    return -(-x)**(1/3)


def roots_cubic(a,b,c,d):
  # output : roots of the polynomial a*x^3 + b*x^2 + c*x + d = 0

  p = (3*a*c - b**2)/(3*a**2)
  q = (2* b**3 - 9*a*b*c + 27* a**2 *d ) / (27 * a**3)


  delta = - 4 * p**3 - 27* q**2        #( 13*a*b*c*d - 4* b**3 *d + b**2 * c**2 - 4*a* c**3 - 27* a**2 * d**2 )/ (a**4)
  print(delta)


  roots = []

  j_ = np.exp((2*1j*np.pi)/3)

  for k in range(3):

    u_k = j_**k * sqrt_3( 0.5 * (-q + np.sqrt(-delta/27,dtype=complex)) )   #pb dans le calcul de la racine cubique !!
    v_k = j_**(-k) * sqrt_3( 0.5 * (-q - np.sqrt(-delta/27,dtype=complex)))

    roots.append((u_k + v_k)- b/(3*a))

  return np.array(roots)

import numpy as np

# Test of roots_cubic
def test_roots_cubic(a,b,c,d):
  print("f(x) = ",a,"*x**3 + ",b,"*x**2 + ",c,"*x + ",d)
  def f(x,a,b,c,d):

    return a*x**3 + b*x**2 + c*x + d


  roots = roots_cubic(a,b,c,d)

  print('Roots :', roots,'\n')

  valeur_ok = True
  for r in roots :
    y = f(r,a,b,c,d)
    print('f(r) = ',y,'\n')
    if np.linalg.norm(y) > 10**(-10) :
      valeur_ok = False
  print('Valeurs inférieures en norme à 10^(-10) : ',valeur_ok, '\n')


test_roots_cubic(np.random.uniform(-20,20),np.random.uniform(-20,20),np.random.uniform(-20,20),np.random.uniform(-20,20))

import numpy as np
# Tests of roots_ferrari
def test_roots_ferrari(a0,a1,a2,a3,a4,):
  print("f(x) = ",a4,"*x**4 + ",a3,"*x**3 + ",a2,"*x**2 + ",a1,"*x + ",a0)

  def f(x,a0,a1,a2,a3,a4) :
    return a4*x**4+a3*x**3 + a2*x**2 + a1*x + a0

  roots = roots_ferrari(np.array([a0,a1,a2,a3,a4]))

  print('Roots :', roots,'\n')

  valeur_ok = True
  for r in roots :
    y = f(r,a0,a1,a2,a3,a4)
    print('f(r) = ',y,'\n')
    if np.linalg.norm(y) > 10**(-10) :
      valeur_ok = False
  print('Valeurs inférieures en norme à 10^(-10) : ',valeur_ok, '\n')

test_roots_ferrari(np.random.uniform(-20,20),np.random.uniform(-20,20),np.random.uniform(-20,20),np.random.uniform(-20,20),np.random.uniform(-20,20))